var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
import { BubbleDefaults, useBubbleChart, } from 'gifted-charts-core';
import BarAndLineChartsWrapper from '../Components/BarAndLineChartsWrapper';
import { Fragment, useCallback, useEffect, useMemo, useRef } from 'react';
import { Animated, Easing, I18nManager, Text, View, } from 'react-native';
import { Circle, ForeignObject, Rect, Svg, Line } from 'react-native-svg';
import { isWebApp, screenWidth } from '../utils';
var AnimatedCircle = Animated.createAnimatedComponent(Circle);
var AnimatedRect = Animated.createAnimatedComponent(Rect);
var AnimatedLine = Animated.createAnimatedComponent(Line);
export var BubbleChart = function (props) {
    var _a, _b, _c, _d, _e, _f;
    var opacityValue = useMemo(function () { return new Animated.Value(0); }, []);
    var pointsOpacityValue = useMemo(function () { return new Animated.Value(0); }, []);
    var secondaryXAxis = props.secondaryXAxis, xAxisLabelTextStyle = props.xAxisLabelTextStyle, formatBubbleLabel = props.formatBubbleLabel;
    var _g = useBubbleChart(__assign(__assign({}, props), { parentWidth: (_a = props.parentWidth) !== null && _a !== void 0 ? _a : screenWidth })), barAndLineChartsWrapperProps = _g.barAndLineChartsWrapperProps, totalWidth = _g.totalWidth, animationDuration = _g.animationDuration, _h = _g.containerHeightIncludingBelowXAxis, containerHeightIncludingBelowXAxis = _h === void 0 ? 0 : _h, getY = _g.getY, getX = _g.getX, maxValue = _g.maxValue, selectedIndex = _g.selectedIndex, setSelectedIndex = _g.setSelectedIndex, showTextOnFocus = _g.showTextOnFocus, focusEnabled = _g.focusEnabled, focusTogether = _g.focusTogether, selectedLineNumber = _g.selectedLineNumber, lastLineNumber = _g.lastLineNumber, initialSpacing = _g.initialSpacing, spacing = _g.spacing, containerHeight = _g.containerHeight, handleFocus = _g.handleFocus, handleUnFocus = _g.handleUnFocus, isAnimated = _g.isAnimated, showBubbleOnFocus = _g.showBubbleOnFocus, showBubbleLabelOnFocus = _g.showBubbleLabelOnFocus, bubblesShape = _g.bubblesShape, bubblesWidth = _g.bubblesWidth, bubblesHeight = _g.bubblesHeight, bubblesColor = _g.bubblesColor, bubblesRadius = _g.bubblesRadius, labelFontSize = _g.labelFontSize, labelTextStyle = _g.labelTextStyle, startIndex = _g.startIndex, endIndex = _g.endIndex, showValuesAsBubbleLabels = _g.showValuesAsBubbleLabels, hideBubbles = _g.hideBubbles, xAxisLabelsVerticalShift = _g.xAxisLabelsVerticalShift, labelsExtraHeight = _g.labelsExtraHeight, xAxisThickness = _g.xAxisThickness, xAxisTextNumberOfLines = _g.xAxisTextNumberOfLines, rotateLabel = _g.rotateLabel, allowFontScaling = _g.allowFontScaling, borderColor = _g.borderColor, borderWidth = _g.borderWidth, opacity = _g.opacity, xAxisLabelTexts = _g.xAxisLabelTexts, showRegressionLine = _g.showRegressionLine, regressionLineX1 = _g.regressionLineX1, regressionLineY1 = _g.regressionLineY1, regressionLineX2 = _g.regressionLineX2, regressionLineY2 = _g.regressionLineY2, regressionLineConfig = _g.regressionLineConfig, scatterChart = _g.scatterChart;
    var progress = useRef(new Animated.Value(0)).current;
    var AnimatedRegressionLineX = useRef(new Animated.Value(0)).current;
    var AnimatedRegressionLineY = useRef(new Animated.Value(0)).current;
    var scrollRef = (_b = props.scrollRef) !== null && _b !== void 0 ? _b : useRef(null);
    var widthValue = useMemo(function () { return new Animated.Value(0); }, []);
    var appearingOpacity = opacityValue.interpolate({
        inputRange: [0, 1],
        outputRange: [0, 1],
    });
    // const appearRegressionLine = RegressionLine.interpolate({
    //   inputRange:[0,1],
    //   outputRange:[regressionLineX1,regressionLineX2]
    // })
    var growingRadii = useMemo(function () {
        var _a;
        return ((_a = props.data) !== null && _a !== void 0 ? _a : []).map(function (item) {
            var _a;
            return progress.interpolate({
                inputRange: [0, 1],
                outputRange: [0, (_a = item.r) !== null && _a !== void 0 ? _a : bubblesRadius],
            });
        });
    }, [props.data, progress]);
    var growingHeight = ((_c = props.data) !== null && _c !== void 0 ? _c : []).map(function (_, i) {
        var _a, _b;
        return progress.interpolate({
            inputRange: [0, 1],
            outputRange: [0, (_b = (_a = props.data) === null || _a === void 0 ? void 0 : _a[i].bubbleHeight) !== null && _b !== void 0 ? _b : bubblesHeight],
        });
    });
    var growingWidth = ((_d = props.data) !== null && _d !== void 0 ? _d : []).map(function (_, i) {
        var _a, _b;
        return progress.interpolate({
            inputRange: [0, 1],
            outputRange: [0, (_b = (_a = props.data) === null || _a === void 0 ? void 0 : _a[i].bubbleWidth) !== null && _b !== void 0 ? _b : bubblesWidth],
        });
    });
    var appearingDataPoints = pointsOpacityValue.interpolate({
        inputRange: [0, 1],
        outputRange: [0, opacity],
    });
    var drawRegressionLine = useCallback(function () {
        if (!regressionLineConfig.isAnimated)
            return;
        AnimatedRegressionLineX.setValue(regressionLineX1);
        AnimatedRegressionLineY.setValue(regressionLineY1);
        Animated.parallel([
            Animated.timing(AnimatedRegressionLineX, {
                toValue: regressionLineX2,
                duration: regressionLineConfig.animationDuration,
                easing: Easing.linear,
                useNativeDriver: false, // SVG props
            }),
            Animated.timing(AnimatedRegressionLineY, {
                toValue: regressionLineY2,
                duration: regressionLineConfig.animationDuration,
                easing: Easing.linear,
                useNativeDriver: false, // SVG props
            }),
        ]).start();
    }, [regressionLineConfig]);
    var decreaseWidth = useCallback(function () {
        widthValue.setValue(0);
        Animated.timing(widthValue, {
            toValue: totalWidth,
            duration: animationDuration,
            easing: Easing.linear,
            useNativeDriver: false,
        }).start();
    }, [animationDuration, widthValue]);
    var labelsAppear = useCallback(function () {
        opacityValue.setValue(0);
        Animated.timing(opacityValue, {
            toValue: 1,
            duration: 500,
            easing: Easing.ease,
            useNativeDriver: false,
        }).start();
    }, [opacityValue]);
    var radiiGrow = useCallback(function () {
        if (bubblesShape === 'rectangular')
            return;
        progress.setValue(0);
        Animated.timing(progress, {
            toValue: 1,
            duration: animationDuration,
            easing: Easing.out(Easing.cubic),
            useNativeDriver: false,
        }).start();
    }, [progress, animationDuration]);
    var bubblesHeightsWidthsGrow = useCallback(function () {
        if (bubblesShape !== 'rectangular')
            return;
        progress.setValue(0);
        Animated.timing(progress, {
            toValue: 1,
            duration: animationDuration,
            easing: Easing.out(Easing.cubic),
            useNativeDriver: false,
        }).start();
    }, [progress, animationDuration]);
    var dataPointsAppear = useCallback(function () {
        pointsOpacityValue.setValue(0);
        Animated.timing(pointsOpacityValue, {
            toValue: 1,
            duration: animationDuration,
            easing: Easing.ease,
            useNativeDriver: false,
        }).start();
    }, [pointsOpacityValue]);
    useEffect(function () {
        if (isAnimated) {
            decreaseWidth();
            labelsAppear();
            dataPointsAppear();
            if (bubblesShape === 'rectangular') {
                bubblesHeightsWidthsGrow();
            }
            else {
                radiiGrow();
            }
        }
        if (regressionLineConfig.isAnimated) {
            drawRegressionLine();
        }
    }, [isAnimated, bubblesShape]);
    var svgHeight = containerHeightIncludingBelowXAxis + ((_e = props.overflowBottom) !== null && _e !== void 0 ? _e : 0);
    // const onStripPress = (item: any, index: number) => {
    //   if (props.focusedBubbleIndex === undefined || !props.onFocus) {
    //     setSelectedIndex(index);
    //   }
    //   if (props.onFocus) {
    //     props.onFocus(item, index);
    //   }
    // };
    var renderLabel = function (top, index, label) {
        var _a, _b;
        return (_jsx(View, { style: [
                {
                    position: 'absolute',
                    bottom: top
                        ? containerHeight +
                            60 +
                            ((_a = secondaryXAxis === null || secondaryXAxis === void 0 ? void 0 : secondaryXAxis.labelsDistanceFromXaxis) !== null && _a !== void 0 ? _a : 15)
                        : -xAxisTextNumberOfLines * 18 - (containerHeight - 200) / 20,
                    zIndex: 10,
                    width: spacing + labelsExtraHeight,
                    left: initialSpacing + spacing * index - spacing / 2,
                    height: (_b = props.xAxisLabelsHeight) !== null && _b !== void 0 ? _b : xAxisTextNumberOfLines * 18,
                },
                rotateLabel && { transform: [{ rotate: '60deg' }] },
            ], children: _jsx(Text, { style: [{ textAlign: 'center' }, xAxisLabelTextStyle], allowFontScaling: allowFontScaling, numberOfLines: xAxisTextNumberOfLines, children: label }) }));
    };
    var renderAnimatedLabel = function (top, index, label) {
        var _a, _b;
        return (_jsx(Animated.View, { style: [
                {
                    height: rotateLabel
                        ? 40
                        : ((_a = props.xAxisLabelsHeight) !== null && _a !== void 0 ? _a : xAxisTextNumberOfLines * 18),
                    position: 'absolute',
                    bottom: top
                        ? containerHeight +
                            60 +
                            ((_b = secondaryXAxis === null || secondaryXAxis === void 0 ? void 0 : secondaryXAxis.labelsDistanceFromXaxis) !== null && _b !== void 0 ? _b : 15)
                        : rotateLabel
                            ? 10
                            : -xAxisTextNumberOfLines * 18,
                    zIndex: 10,
                    width: spacing,
                    left: initialSpacing + spacing * index - spacing / 2,
                    opacity: appearingOpacity,
                },
                rotateLabel && { transform: [{ rotate: '60deg' }] },
            ], children: _jsx(Text, { allowFontScaling: allowFontScaling, style: [{ textAlign: 'center' }, xAxisLabelTextStyle], numberOfLines: xAxisTextNumberOfLines, children: label }) }));
    };
    var renderBubbles = function (hideBubbles, dataForRender, originalDataFromProps, bubsShape, bubsWidth, bubsHeight, bubsColor, bubsRadius, labelFontSize, startIndex, endIndex, isSecondary, showValuesAsDataPointsText, key) {
        var getYOrSecondaryY = getY; //isSecondary ? getSecondaryY : getY;
        return dataForRender.map(function (item, index) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
            if (index < startIndex || index > endIndex)
                return null;
            if (item.hideBubble) {
                return null;
            }
            var bubblesShape, bubblesWidth, bubblesHeight, dataPointsColor, bubblesRadius, text, customBubble, labelComponent;
            if (index === selectedIndex &&
                (focusTogether || key === selectedLineNumber)) {
                bubblesShape =
                    item.focusedBubbleShape ||
                        props.focusedBubbleShape ||
                        item.bubbleShape ||
                        bubsShape;
                bubblesWidth =
                    item.focusedBubbleWidth ||
                        props.focusedBubbleWidth ||
                        item.bubbleWidth ||
                        bubsWidth;
                bubblesHeight =
                    item.focusedBubbleHeight ||
                        props.focusedBubbleHeight ||
                        item.bubbleHeight ||
                        bubsHeight;
                dataPointsColor =
                    item.focusedBubbleColor ||
                        props.focusedBubbleColor ||
                        BubbleDefaults.focusedBubbleColor;
                bubblesRadius =
                    (_c = (_b = (_a = item.focusedBubbleRadius) !== null && _a !== void 0 ? _a : props.focusedBubbleRadius) !== null && _b !== void 0 ? _b : item.r) !== null && _c !== void 0 ? _c : bubsRadius;
                if (showTextOnFocus) {
                    text = item.label;
                }
                customBubble =
                    item.focusedCustomBubble ||
                        props.focusedCustomBubble ||
                        item.customBubble ||
                        props.customBubble;
                labelComponent =
                    item.focusedLabelComponent ||
                        item.labelComponent ||
                        props.focusedLabelComponent ||
                        props.labelComponent;
            }
            else {
                bubblesShape = item.bubbleShape || bubsShape;
                bubblesWidth = item.bubbleWidth || bubsWidth;
                bubblesHeight = item.bubbleHeight || bubsHeight;
                dataPointsColor = item.bubbleColor || bubsColor;
                bubblesRadius = (_d = item.r) !== null && _d !== void 0 ? _d : bubsRadius;
                if (showTextOnFocus) {
                    text = '';
                }
                customBubble = item.customBubble || props.customBubble;
                labelComponent = item.labelComponent || props.labelComponent;
            }
            if (showValuesAsDataPointsText) {
                text = originalDataFromProps[index].y;
            }
            var labelWidth = item.labelWidth
                ? item.labelWidth
                : props.labelWidth
                    ? props.labelWidth
                    : 30;
            var textLabel = !showTextOnFocus && !showValuesAsDataPointsText
                ? item.label
                : text.toString();
            var formattedTextLabel = textLabel
                ? ((_e = formatBubbleLabel === null || formatBubbleLabel === void 0 ? void 0 : formatBubbleLabel(textLabel)) !== null && _e !== void 0 ? _e : textLabel)
                : '';
            var textStyle = ((_g = (_f = item.labelTextStyle) !== null && _f !== void 0 ? _f : labelTextStyle) !== null && _g !== void 0 ? _g : {});
            var fontSize = textStyle.fontSize || item.labelFontSize || labelFontSize;
            var defaultFontSize = 14;
            return (_jsxs(Fragment, { children: [focusEnabled ? (_jsx(_Fragment, { children: key === lastLineNumber - 1 ? (_jsx(Rect, { x: initialSpacing + (spacing * index - spacing / 2), y: 8, width: spacing, height: containerHeight - 0, fill: 'none', onPressIn: function (evt) {
                                var locationY = evt.nativeEvent.locationY; // Note that we have another property named pageY which can be useful
                                handleFocus(index);
                            }, onPressOut: handleUnFocus })) : null })) : null, hideBubbles ? null : (_jsxs(_Fragment, { children: [customBubble ? (isWebApp ? (_jsx(ForeignObject, { height: svgHeight, width: totalWidth, x: getX(index), y: getYOrSecondaryY(item.y) - bubblesHeight / 2, children: customBubble(item, index) })) : (_jsx(Animated.View, { style: {
                                    position: 'absolute',
                                    // height: svgHeight,
                                    // width: totalWidth,
                                    left: getX(index) - bubblesWidth / 2,
                                    top: getYOrSecondaryY(item.y) - bubblesHeight / 2,
                                    opacity: isAnimated ? appearingOpacity : 1,
                                }, children: customBubble(item, index) }))) : null, bubblesShape === 'rectangular' ? (_jsx(Fragment, { children: customBubble ? null : (_jsx(AnimatedRect, { x: getX(index) - bubblesWidth / 2, y: getYOrSecondaryY(item.y) - bubblesHeight / 2, width: isAnimated ? growingWidth[index] : bubblesWidth, height: isAnimated ? growingHeight[index] : bubblesHeight, opacity: isAnimated ? appearingDataPoints : opacity, fill: showBubbleOnFocus
                                        ? index === selectedIndex
                                            ? dataPointsColor
                                            : 'none'
                                        : dataPointsColor, stroke: (_h = item.borderColor) !== null && _h !== void 0 ? _h : borderColor, strokeWidth: (_j = item.borderWidth) !== null && _j !== void 0 ? _j : borderWidth, strokeOpacity: (_l = (_k = item.borderOpacity) !== null && _k !== void 0 ? _k : props.borderOpacity) !== null && _l !== void 0 ? _l : (isAnimated ? appearingDataPoints : opacity), onPress: function () {
                                        item.onPress
                                            ? item.onPress(item, index)
                                            : props.onPress
                                                ? props.onPress(item, index)
                                                : focusEnabled
                                                    ? handleFocus(index)
                                                    : null;
                                    }, onPressOut: function () {
                                        if (!item.onPress && !props.onPress && focusEnabled) {
                                            handleUnFocus();
                                        }
                                    } })) }, index)) : (_jsx(Fragment, { children: customBubble ? null : (_jsx(AnimatedCircle, { cx: getX(index), cy: getYOrSecondaryY(item.y), r: isAnimated ? growingRadii[index] : bubblesRadius, fill: showBubbleOnFocus
                                        ? index === selectedIndex
                                            ? dataPointsColor
                                            : 'none'
                                        : dataPointsColor, opacity: isAnimated ? appearingDataPoints : opacity, stroke: (_m = item.borderColor) !== null && _m !== void 0 ? _m : borderColor, strokeWidth: (_o = item.borderWidth) !== null && _o !== void 0 ? _o : borderWidth, strokeOpacity: (_q = (_p = item.borderOpacity) !== null && _p !== void 0 ? _p : props.borderOpacity) !== null && _q !== void 0 ? _q : (isAnimated ? appearingDataPoints : opacity), onPress: function () {
                                        item.onPress
                                            ? item.onPress(item, index)
                                            : props.onPress
                                                ? props.onPress(item, index)
                                                : focusEnabled
                                                    ? handleFocus(index)
                                                    : null;
                                    }, onPressOut: function () {
                                        if (!item.onPress && !props.onPress && focusEnabled) {
                                            handleUnFocus();
                                        }
                                    } })) }, index)), labelComponent ? (!showTextOnFocus || index === selectedIndex ? (isWebApp ? (_jsx(ForeignObject, { height: svgHeight, width: totalWidth, x: getX(index) -
                                    labelWidth / 2 +
                                    6 +
                                    (item.labelShiftX || props.labelShiftX || 0), y: getYOrSecondaryY(item.y) -
                                    10 +
                                    (item.labelShiftY || props.labelShiftY || 0) -
                                    (scatterChart ? bubblesRadius + 10 : 0), children: showBubbleLabelOnFocus
                                    ? index === selectedIndex &&
                                        (focusTogether || key == selectedLineNumber)
                                        ? labelComponent(item, index) // not pushed in latest release
                                        : null
                                    : labelComponent(item, index) })) : (_jsx(Animated.View, { style: {
                                    position: 'absolute',
                                    height: svgHeight,
                                    width: labelWidth,
                                    left: getX(index) -
                                        defaultFontSize / 2 +
                                        (item.labelShiftX || props.labelShiftX || 0),
                                    top: getYOrSecondaryY(item.y) -
                                        defaultFontSize / 1.5 +
                                        (item.labelShiftY || props.labelShiftY || 0) -
                                        (scatterChart ? bubblesRadius + 10 : 0),
                                    opacity: isAnimated ? appearingDataPoints : 1,
                                }, children: showBubbleLabelOnFocus
                                    ? index === selectedIndex &&
                                        (focusTogether || key == selectedLineNumber)
                                        ? labelComponent(item, index) // not pushed in latest release
                                        : null
                                    : labelComponent(item, index) }))) : null) : formattedTextLabel ? (!showTextOnFocus || index === selectedIndex ? (isWebApp ? (_jsx(ForeignObject, { height: svgHeight, width: totalWidth, x: getX(index) -
                                    Math.min(bubblesRadius, (formattedTextLabel.length * fontSize) / 3) +
                                    (item.labelShiftX || props.labelShiftX || 0), y: getYOrSecondaryY(item.y) -
                                    Math.max(10, fontSize / 1.5) +
                                    (item.labelShiftY || props.labelShiftY || 0) -
                                    (scatterChart ? bubblesRadius + 10 : 0), children: _jsx(Text, { style: __assign(__assign({}, textStyle), { fontSize: fontSize }), children: formattedTextLabel }) })) : (_jsx(Animated.Text, { style: __assign(__assign({}, textStyle), { position: 'absolute', left: getX(index) -
                                        Math.min(bubblesRadius, (formattedTextLabel.length * fontSize) / 3) +
                                        (item.labelShiftX || props.labelShiftX || 0), top: getYOrSecondaryY(item.y) -
                                        fontSize / 1.5 +
                                        (item.labelShiftY || props.labelShiftY || 0) -
                                        (scatterChart ? bubblesRadius + 10 : 0), fontSize: fontSize, opacity: isAnimated
                                        ? appearingDataPoints
                                        : ((_r = textStyle.opacity) !== null && _r !== void 0 ? _r : 1) }), children: formattedTextLabel }))) : null) : null, index === selectedIndex ? _jsx(Text, { children: '' }) : null] }))] }, index));
        });
    };
    var svgWrapperViewStyle = {
        position: 'absolute',
        top: 0, // 281 + xAxisLabelsVerticalShift + labelsExtraHeight - xAxisThickness,
        left: 0,
        zIndex: 1,
        transform: [{ scaleX: I18nManager.isRTL ? -1 : 1 }],
    };
    var renderChartContent = function () {
        return (_jsxs(View, { style: [
                svgWrapperViewStyle,
                {
                    width: totalWidth,
                    height: containerHeightIncludingBelowXAxis,
                    //   zIndex,
                },
            ], children: [_jsxs(Svg, { height: svgHeight, width: totalWidth, onPress: props.onBackgroundPress, children: [renderBubbles(hideBubbles, props.data, props.data, bubblesShape, bubblesWidth, bubblesHeight, bubblesColor, bubblesRadius, labelFontSize, startIndex, endIndex, false, showValuesAsBubbleLabels, 0), showRegressionLine && (_jsx(AnimatedLine, { x1: regressionLineX1, y1: regressionLineY1, x2: regressionLineConfig.isAnimated
                                ? AnimatedRegressionLineX
                                : regressionLineX2, y2: regressionLineConfig.isAnimated
                                ? AnimatedRegressionLineY
                                : regressionLineY2, stroke: regressionLineConfig.color, strokeOpacity: regressionLineConfig.opacity, strokeWidth: regressionLineConfig.thickness, strokeDasharray: regressionLineConfig.strokeDashArray }))] }), xAxisLabelTexts === null || xAxisLabelTexts === void 0 ? void 0 : xAxisLabelTexts.map(function (label, index) {
                    return (_jsx(View, { children: isAnimated
                            ? renderAnimatedLabel(false, index, label)
                            : renderLabel(false, index, label) }, index));
                })] }));
    };
    var remainingScrollViewProps = {
        onScroll: function (ev) {
            var _a;
            (_a = props.onScroll) === null || _a === void 0 ? void 0 : _a.call(props, ev);
        },
        bounces: props.bounces,
        overScrollMode: (_f = props.overScrollMode) !== null && _f !== void 0 ? _f : 'auto',
    };
    return (_jsx(BarAndLineChartsWrapper, __assign({}, barAndLineChartsWrapperProps, { scrollRef: scrollRef, animatedWidth: widthValue, renderChartContent: renderChartContent, remainingScrollViewProps: remainingScrollViewProps, nestedScrollEnabled: props.nestedScrollEnabled })));
};
