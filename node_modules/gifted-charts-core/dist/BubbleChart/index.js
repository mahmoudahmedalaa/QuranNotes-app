var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
import { useState } from 'react';
import { computeMaxAndMinXForBubble, computeMaxAndMinYForBubble, getAxesAndRulesProps, getExtendedContainerHeightWithPadding, getMaxValue, getNoOfSections, indexOfFirstNonZeroDigit
// weightedRegression
 } from '../utils';
import { AxesAndRulesDefaults, BubbleDefaults, chartTypes, LineDefaults } from '../utils/constants';
export var useBubbleChart = function (props) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54;
    var _55 = props.data, data = _55 === void 0 ? [] : _55, formatXLabel = props.formatXLabel;
    var yNoOfSections = getNoOfSections(props.yNoOfSections, props.maxY, props.yStepValue);
    var containerHeight = (_a = props.height) !== null && _a !== void 0 ? _a : (((_b = props.yStepHeight) !== null && _b !== void 0 ? _b : 0) * yNoOfSections ||
        AxesAndRulesDefaults.containerHeight);
    var yRange = Math.max.apply(Math, __spreadArray([], __read(data.map(function (i) { return Math.max(i.y, 0); })), false)) - // find the largest +ve number
     Math.min.apply(// find the largest +ve number
    Math, __spreadArray([], __read(data.map(function (i) { return Math.max(i.y, 0); })), false)); // find the smallest +ve number
    var showFractionalYAxis = (_c = props.showFractionalYAxis) !== null && _c !== void 0 ? _c : (isFinite(yRange) && yRange <= 1);
    var roundToDigits = (_d = props.yRoundToDigits) !== null && _d !== void 0 ? _d : (showFractionalYAxis ? indexOfFirstNonZeroDigit(yRange) + 1 : 0);
    var bubblesRadius = (_e = props.bubblesRadius) !== null && _e !== void 0 ? _e : BubbleDefaults.bubblesRadius;
    var _56 = computeMaxAndMinYForBubble(data, false, // extrapolateMissingValues
    roundToDigits, showFractionalYAxis, data), yMaxItem = _56.maxItem, yMinItem = _56.minItem;
    // Find the maximum radius across all bubbles to account for bubble size in chart bounds
    var maxBubbleRadius = props.hideBubbles
        ? 0
        : data.length > 0
            ? Math.max.apply(Math, __spreadArray([bubblesRadius], __read(data.map(function (item) { var _a; return (_a = item.r) !== null && _a !== void 0 ? _a : bubblesRadius; })), false)) : bubblesRadius;
    var maxYInitial = getMaxValue(props.maxY, props.yStepValue, yNoOfSections, yMaxItem) || 10;
    var mostNegativeYInitial = (_f = props.mostNegativeY) !== null && _f !== void 0 ? _f : yMinItem;
    var onlyPositive = (_g = props.onlyPositive) !== null && _g !== void 0 ? _g : mostNegativeYInitial >= 0;
    var horizSections = [{ value: '0' }];
    var yStepHeight = (_h = props.yStepHeight) !== null && _h !== void 0 ? _h : containerHeight / yNoOfSections;
    // Adjust maxY to account for bubble radius at the top of the chart
    // Convert max bubble radius from screen pixels to Y value space
    var maxYRadiusPadding = containerHeight > 0 ? (maxBubbleRadius * maxYInitial) / containerHeight : 0;
    var maxY = (_j = props.maxY) !== null && _j !== void 0 ? _j : maxYInitial + maxYRadiusPadding;
    var yStepValue = (_k = props.yStepValue) !== null && _k !== void 0 ? _k : maxY / yNoOfSections;
    var yNegativeStepValue = (_l = props.yNegativeStepValue) !== null && _l !== void 0 ? _l : yStepValue;
    // Adjust mostNegativeY to account for bubble radius at the bottom of the chart
    // Convert max bubble radius from screen pixels to Y value space for negative values
    // Use an approximation: assume the negative quadrant height is roughly proportional to the absolute value
    var mostNegativeYRadiusPadding = containerHeight > 0 && mostNegativeYInitial < 0
        ? (maxBubbleRadius * Math.abs(mostNegativeYInitial)) / containerHeight
        : 0;
    var mostNegativeY = mostNegativeYInitial < 0
        ? mostNegativeYInitial - mostNegativeYRadiusPadding
        : mostNegativeYInitial;
    var xRange = Math.max.apply(Math, __spreadArray([], __read(data.map(function (i) { return Math.max(i.x, 0); })), false)) - // find the largest +ve number
     Math.min.apply(// find the largest +ve number
    Math, __spreadArray([], __read(data.map(function (i) { return Math.max(i.x, 0); })), false)); // find the smallest +ve number
    var showFractionalXAxis = (_m = props.showFractionalXAxis) !== null && _m !== void 0 ? _m : (isFinite(xRange) && xRange <= 1);
    var xRoundToDigits = (_o = props.xRoundToDigits) !== null && _o !== void 0 ? _o : (showFractionalXAxis ? indexOfFirstNonZeroDigit(xRange) + 1 : 0);
    var _57 = computeMaxAndMinXForBubble(data, false, // extrapolateMissingValues
    xRoundToDigits, showFractionalXAxis, data), xMaxItem = _57.maxItem, xMinItem = _57.minItem;
    var xNoOfSections = getNoOfSections(props.xNoOfSections, props.maxX, props.xStepValue, true);
    var maxXInitial = getMaxValue(props.maxX, props.xStepValue, xNoOfSections, xMaxItem) || 10;
    var minXInitial = xMinItem;
    // Adjust minX and maxX to account for bubble radius on left and right sides
    // Convert max bubble radius from screen pixels to X value space
    // We'll need spacing and totalWidth for accurate conversion, but we can use an approximation first
    // For now, we'll adjust after we have spacing calculated
    var xRangeInitial = maxXInitial - minXInitial;
    // const xStepHeight = props.xStepHeight ?? containerHeight / yNoOfSections
    // Calculate xStepValue based on the range instead of just maxX
    var xStepValue = (_p = props.xStepValue) !== null && _p !== void 0 ? _p : (xRangeInitial > 0
        ? xRangeInitial / xNoOfSections
        : maxXInitial / xNoOfSections);
    var initialSpacing = (_q = props.initialSpacing) !== null && _q !== void 0 ? _q : BubbleDefaults.initialSpacing;
    var endSpacing = (_r = props.endSpacing) !== null && _r !== void 0 ? _r : BubbleDefaults.endSpacing;
    // Calculate initial spacing estimate for radius conversion
    // We'll refine this after adjusting minX/maxX
    var estimatedSpacing = (_s = props.spacing) !== null && _s !== void 0 ? _s : (props.width
        ? (props.width - initialSpacing - endSpacing) / xNoOfSections
        : BubbleDefaults.spacing);
    // Adjust minX and maxX to account for bubble radius on left and right sides
    // Convert max bubble radius from screen pixels to X value space
    var estimatedXRange = maxXInitial - minXInitial;
    // Calculate scale: pixels per unit in data space
    // estimatedSpacing is pixels per section, so scale = (pixels/section) / (dataUnits/section)
    var estimatedXScale = estimatedXRange > 0 && estimatedSpacing > 0
        ? (estimatedSpacing * xNoOfSections) / estimatedXRange
        : 1;
    var maxXRadiusPadding = estimatedXScale > 0 ? maxBubbleRadius / estimatedXScale : 0;
    var minXRadiusPadding = estimatedXScale > 0 ? maxBubbleRadius / estimatedXScale : 0;
    var minX = minXInitial - minXRadiusPadding;
    var maxX = (_t = props.maxX) !== null && _t !== void 0 ? _t : maxXInitial + maxXRadiusPadding;
    var xRangeAdjusted = maxX - minX;
    // Recalculate xStepValue based on adjusted range
    var xStepValueAdjusted = (_u = props.xStepValue) !== null && _u !== void 0 ? _u : (xRangeAdjusted > 0 ? xRangeAdjusted / xNoOfSections : xStepValue);
    var xAxisLabelTexts = (_v = props.xAxisLabelTexts) !== null && _v !== void 0 ? _v : Array.from({ length: xNoOfSections + 1 }, function (_, i) {
        if (i === 0 && initialSpacing === 0)
            return '';
        var labelText = (minX + xStepValueAdjusted * i)
            .toFixed(xRoundToDigits)
            .toString();
        if (formatXLabel) {
            return formatXLabel(labelText);
        }
        return labelText;
    });
    var noOfSectionsBelowXAxis = (_w = props.noOfSectionsBelowXAxis) !== null && _w !== void 0 ? _w : Math.round(Math.ceil(-mostNegativeY / yNegativeStepValue));
    var labelsExtraHeight = (_x = props.labelsExtraHeight) !== null && _x !== void 0 ? _x : 0;
    var yAxisLabelWidth = (_y = props.yAxisLabelWidth) !== null && _y !== void 0 ? _y : (props.hideYAxisText
        ? AxesAndRulesDefaults.yAxisEmptyLabelWidth
        : AxesAndRulesDefaults.yAxisLabelWidth);
    var horizontal = false;
    var yAxisAtTop = false;
    var xAxisThickness = (_z = props.xAxisThickness) !== null && _z !== void 0 ? _z : AxesAndRulesDefaults.xAxisThickness;
    var spacing = (_0 = props.spacing) !== null && _0 !== void 0 ? _0 : (props.width
        ? (props.width - initialSpacing - endSpacing) /
            (xAxisLabelTexts.length - 1)
        : BubbleDefaults.spacing);
    var totalWidth = initialSpacing + spacing * (xAxisLabelTexts.length - 1) + endSpacing;
    var disableScroll = (_1 = props.disableScroll) !== null && _1 !== void 0 ? _1 : false;
    var showScrollIndicator = (_2 = props.showScrollIndicator) !== null && _2 !== void 0 ? _2 : false;
    var scrollToEnd = (_3 = props.scrollToEnd) !== null && _3 !== void 0 ? _3 : false;
    var scrollAnimation = (_4 = props.scrollAnimation) !== null && _4 !== void 0 ? _4 : false;
    var scrollEventThrottle = (_5 = props.scrollEventThrottle) !== null && _5 !== void 0 ? _5 : 16;
    var focusEnabled = (_6 = props.focusEnabled) !== null && _6 !== void 0 ? _6 : LineDefaults.focusEnabled;
    var showBubbleOnFocus = (_7 = props.showBubbleOnFocus) !== null && _7 !== void 0 ? _7 : BubbleDefaults.showBubbleOnFocus;
    var _58 = __read(useState((_8 = props.focusedBubbleIndex) !== null && _8 !== void 0 ? _8 : -1), 2), selectedIndex = _58[0], setSelectedIndex = _58[1];
    var _59 = __read(useState(''), 2), points = _59[0], setPoints = _59[1];
    var _60 = __read(useState(-1), 2), pointerIndex = _60[0], setPointerIndex = _60[1];
    var _61 = __read(useState(0), 2), pointerX = _61[0], setPointerX = _61[1];
    var _62 = __read(useState(0), 2), pointerY = _62[0], setPointerY = _62[1];
    var isAnimated = (_9 = props.isAnimated) !== null && _9 !== void 0 ? _9 : false;
    var horizontalRulesStyle = props.horizontalRulesStyle;
    var yAxisOffset = (_10 = props.yAxisOffset) !== null && _10 !== void 0 ? _10 : 0;
    var showXAxisIndices = (_11 = props.showXAxisIndices) !== null && _11 !== void 0 ? _11 : AxesAndRulesDefaults.showXAxisIndices;
    var xAxisIndicesHeight = (_12 = props.xAxisIndicesHeight) !== null && _12 !== void 0 ? _12 : AxesAndRulesDefaults.xAxisIndicesHeight;
    var xAxisIndicesWidth = (_13 = props.xAxisIndicesWidth) !== null && _13 !== void 0 ? _13 : AxesAndRulesDefaults.xAxisIndicesWidth;
    var xAxisIndicesColor = (_14 = props.xAxisIndicesColor) !== null && _14 !== void 0 ? _14 : AxesAndRulesDefaults.xAxisIndicesColor;
    //   const pointerConfig = props.pointerConfig
    var getPointerProps = (_15 = props.getPointerProps) !== null && _15 !== void 0 ? _15 : null;
    var bubblesWidth = (_16 = props.bubblesWidth) !== null && _16 !== void 0 ? _16 : BubbleDefaults.bubblesWidth;
    var extraWidthDueToBubble = props.hideBubbles
        ? 0
        : bubblesRadius !== null && bubblesRadius !== void 0 ? bubblesRadius : bubblesWidth;
    var xAxisLabelsAtBottom = (_17 = props.xAxisLabelsAtBottom) !== null && _17 !== void 0 ? _17 : false;
    var allowFontScaling = (_18 = props.allowFontScaling) !== null && _18 !== void 0 ? _18 : AxesAndRulesDefaults.allowFontScaling;
    var animationDuration = (_19 = props.animationDuration) !== null && _19 !== void 0 ? _19 : LineDefaults.animationDuration;
    var secondaryMaxValue = maxY;
    var secondaryMinItem = maxY * -1;
    var showSecondaryFractionalValues = false;
    var secondaryRoundToDigits = 1;
    var axesAndRulesProps = getAxesAndRulesProps(props, containerHeight, yStepHeight, yStepValue, yNoOfSections, roundToDigits, yNegativeStepValue, secondaryMaxValue, secondaryMinItem, showSecondaryFractionalValues, secondaryRoundToDigits);
    var fourthQuadrantHeight = noOfSectionsBelowXAxis * yStepHeight;
    var extendedContainerHeight = getExtendedContainerHeightWithPadding(containerHeight, 0);
    var containerHeightIncludingBelowXAxis = extendedContainerHeight + fourthQuadrantHeight;
    var mostNegativeValueOnYAxis = yNegativeStepValue * noOfSectionsBelowXAxis;
    var containsNegativeValue = ((_20 = props.mostNegativeY) !== null && _20 !== void 0 ? _20 : 0) < 0 ||
        ((_21 = props.data) === null || _21 === void 0 ? void 0 : _21.some(function (item) { var _a; return ((_a = item.y) !== null && _a !== void 0 ? _a : 0) < 0; }));
    // Use adjusted xStepValue for scale calculation
    var xScale = spacing / xStepValueAdjusted;
    var getX = function (index) {
        var _a, _b, _c, _d, _e, _f, _g;
        var val = ((_a = props.data) === null || _a === void 0 ? void 0 : _a[index].x) !== undefined
            ? (((_c = (_b = props.data) === null || _b === void 0 ? void 0 : _b[index].x) !== null && _c !== void 0 ? _c : 0) - minX) * xScale // redundant ?? just to avoid lint highlighting
            : Math.min(totalWidth -
                ((_e = (_d = props.data) === null || _d === void 0 ? void 0 : _d[index].r) !== null && _e !== void 0 ? _e : BubbleDefaults.bubblesRadius), ((index + 1) * totalWidth) / ((_g = (_f = props.data) === null || _f === void 0 ? void 0 : _f.length) !== null && _g !== void 0 ? _g : 1));
        return val + initialSpacing;
    };
    var getY = function (value) {
        if (containsNegativeValue &&
            value < 0 &&
            yStepValue !== yNegativeStepValue) {
            return (extendedContainerHeight +
                (value * fourthQuadrantHeight) / mostNegativeValueOnYAxis);
        }
        return extendedContainerHeight - (value * containerHeight) / maxY;
    };
    var showTextOnFocus = (_22 = props.showTextOnFocus) !== null && _22 !== void 0 ? _22 : LineDefaults.showTextOnFocus;
    var showBubbleLabelOnFocus = (_23 = props.showBubbleLabelOnFocus) !== null && _23 !== void 0 ? _23 : BubbleDefaults.showBubbleLabelOnFocus;
    var focusTogether = (_24 = props.focusTogether) !== null && _24 !== void 0 ? _24 : true;
    var _63 = __read(useState(-1), 2), selectedLineNumber = _63[0], setSelectedLineNumber = _63[1];
    var lastLineNumber = 1;
    var unFocusOnPressOut = (_25 = props.unFocusOnPressOut) !== null && _25 !== void 0 ? _25 : LineDefaults.unFocusOnPressOut;
    var delayBeforeUnFocus = (_26 = props.delayBeforeUnFocus) !== null && _26 !== void 0 ? _26 : LineDefaults.delayBeforeUnFocus;
    var handleFocus = function (index) {
        setSelectedIndex(index);
    };
    var handleUnFocus = function () {
        if (unFocusOnPressOut) {
            setTimeout(function () { return setSelectedIndex(-1); }, delayBeforeUnFocus);
        }
    };
    var hideBubbles = (_27 = props.hideBubbles) !== null && _27 !== void 0 ? _27 : false;
    var bubblesShape = (_28 = props.bubblesShape) !== null && _28 !== void 0 ? _28 : BubbleDefaults.bubblesShape;
    var bubblesHeight = (_29 = props.bubblesHeight) !== null && _29 !== void 0 ? _29 : BubbleDefaults.bubblesHeight;
    var bubblesColor = (_30 = props.bubblesColor) !== null && _30 !== void 0 ? _30 : BubbleDefaults.bubblesColor;
    var startIndex = 0;
    var endIndex = (_32 = (_31 = props.data) === null || _31 === void 0 ? void 0 : _31.length) !== null && _32 !== void 0 ? _32 : 0;
    var labelFontSize = (_33 = props.labelFontSize) !== null && _33 !== void 0 ? _33 : BubbleDefaults.labelFontSize;
    var showValuesAsBubbleLabels = (_34 = props.showValuesAsBubbleLabels) !== null && _34 !== void 0 ? _34 : BubbleDefaults.showValuesAsBubbleLabels;
    var xAxisLabelsVerticalShift = (_35 = props.xAxisLabelsVerticalShift) !== null && _35 !== void 0 ? _35 : (xAxisLabelsAtBottom
        ? fourthQuadrantHeight
        : AxesAndRulesDefaults.xAxisLabelsVerticalShift);
    var xAxisTextNumberOfLines = (_36 = props.xAxisTextNumberOfLines) !== null && _36 !== void 0 ? _36 : AxesAndRulesDefaults.xAxisTextNumberOfLines;
    var rotateLabel = (_37 = props.rotateLabel) !== null && _37 !== void 0 ? _37 : false;
    var borderWidth = (_38 = props.borderWidth) !== null && _38 !== void 0 ? _38 : BubbleDefaults.borderWidth;
    var borderColor = (_39 = props.borderColor) !== null && _39 !== void 0 ? _39 : BubbleDefaults.borderColor;
    var opacity = (_40 = props.opacity) !== null && _40 !== void 0 ? _40 : BubbleDefaults.opacity;
    var showRegressionLine = (_41 = props.showRegressionLine) !== null && _41 !== void 0 ? _41 : false;
    var weightedRegression = function () {
        var e_1, _a;
        if (!data)
            return { slope: 0, intercept: 0 };
        var sumW = 0;
        var sumWX = 0;
        var sumWY = 0;
        var sumWXX = 0;
        var sumWXY = 0;
        var i = -1;
        try {
            for (var data_1 = __values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
                var _b = data_1_1.value, y = _b.y, _c = _b.r, r = _c === void 0 ? 1 : _c;
                ++i;
                var w = r * r;
                if (w <= 0)
                    continue; // ignore zero/negative weights
                var x = getX(i);
                sumW += w;
                sumWX += w * x;
                sumWY += w * y;
                sumWXX += w * x * x;
                sumWXY += w * x * y;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (data_1_1 && !data_1_1.done && (_a = data_1.return)) _a.call(data_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var denominator = sumW * sumWXX - sumWX * sumWX;
        if (denominator === 0) {
            throw new Error('Regression not defined (degenerate data)');
        }
        var slope = (sumW * sumWXY - sumWX * sumWY) / denominator;
        var intercept = (sumWY - slope * sumWX) / sumW;
        return { slope: slope, intercept: intercept };
    };
    var regressionLineX1 = 0, regressionLineY1 = 0, regressionLineX2 = 0, regressionLineY2 = 0;
    if (showRegressionLine) {
        var slope = 0, intercept = 0;
        var slopeIntercept = weightedRegression();
        slope = slopeIntercept.slope;
        intercept = slopeIntercept.intercept;
        // Calculate Y values in data space first
        var y1_data = slope * minX + intercept;
        var y2_data = slope * maxX + intercept;
        // Convert X coordinates to screen space (matching getX formula)
        regressionLineX1 = initialSpacing;
        regressionLineX2 = (maxX - minX) * xScale + initialSpacing;
        // Convert Y coordinates to screen space using getY function
        regressionLineY1 = getY(y1_data);
        regressionLineY2 = getY(y2_data);
    }
    var regressionLineConfig = {
        thickness: (_43 = (_42 = props.regressionLineConfig) === null || _42 === void 0 ? void 0 : _42.thickness) !== null && _43 !== void 0 ? _43 : BubbleDefaults.regressionLineConfig.thickness,
        color: (_45 = (_44 = props.regressionLineConfig) === null || _44 === void 0 ? void 0 : _44.color) !== null && _45 !== void 0 ? _45 : BubbleDefaults.regressionLineConfig.color,
        opacity: (_47 = (_46 = props.regressionLineConfig) === null || _46 === void 0 ? void 0 : _46.opacity) !== null && _47 !== void 0 ? _47 : BubbleDefaults.regressionLineConfig.opacity,
        strokeDashArray: (_48 = props.regressionLineConfig) === null || _48 === void 0 ? void 0 : _48.strokeDashArray,
        isAnimated: (_50 = (_49 = props.regressionLineConfig) === null || _49 === void 0 ? void 0 : _49.isAnimated) !== null && _50 !== void 0 ? _50 : isAnimated,
        animationDuration: (_52 = (_51 = props.regressionLineConfig) === null || _51 === void 0 ? void 0 : _51.animationDuration) !== null && _52 !== void 0 ? _52 : animationDuration
    };
    var scatterChart = (_53 = props.scatterChart) !== null && _53 !== void 0 ? _53 : BubbleDefaults.scatterChart;
    var barAndLineChartsWrapperProps = {
        chartType: chartTypes.BUBBLE,
        containerHeight: containerHeight,
        noOfSectionsBelowXAxis: noOfSectionsBelowXAxis,
        stepHeight: yStepHeight,
        negativeStepHeight: yStepHeight,
        labelsExtraHeight: labelsExtraHeight,
        yAxisLabelWidth: yAxisLabelWidth,
        horizontal: horizontal,
        rtl: false,
        shiftX: 0,
        shiftY: 0,
        yAxisAtTop: yAxisAtTop,
        initialSpacing: initialSpacing,
        data: data,
        stackData: undefined, // Not needed but passing this prop to maintain consistency (between LineChart and BarChart props)
        secondaryData: undefined, // Not needed but passing this prop to maintain consistency (between LineChart and BarChart props)
        barWidth: 0, // Not needed but passing this prop to maintain consistency (between LineChart and BarChart props)
        xAxisThickness: xAxisThickness,
        totalWidth: totalWidth,
        disableScroll: disableScroll,
        showScrollIndicator: showScrollIndicator,
        scrollToEnd: scrollToEnd,
        scrollToIndex: props.scrollToIndex,
        scrollAnimation: scrollAnimation,
        scrollEventThrottle: scrollEventThrottle,
        indicatorColor: props.indicatorColor,
        selectedIndex: [selectedIndex],
        setSelectedIndex: setSelectedIndex,
        spacing: spacing,
        showLine: false,
        lineConfig: null, // Not needed but passing this prop to maintain consistency (between LineChart and BarChart props)
        lineConfig2: null, // Not needed but passing this prop to maintain consistency (between LineChart and BarChart props)
        maxValue: maxY,
        lineData: [], // Not needed but passing this prop to maintain consistency (between LineChart and BarChart props)
        lineData2: [], // Not needed but passing this prop to maintain consistency (between LineChart and BarChart props)
        lineBehindBars: false,
        points: points,
        points2: '', // Not needed but passing this prop to maintain consistency (between LineChart and BarChart props)
        arrowPoints: [], // Not needed but passing this prop to maintain consistency (between LineChart and BarChart props)
        // horizSectionProps-
        width: props.width,
        horizSections: horizSections,
        endSpacing: endSpacing,
        horizontalRulesStyle: horizontalRulesStyle,
        noOfSections: yNoOfSections,
        sectionColors: props.ySectionColors,
        showFractionalValues: showFractionalYAxis,
        axesAndRulesProps: axesAndRulesProps,
        yAxisLabelTexts: props.yAxisLabelTexts,
        yAxisOffset: yAxisOffset,
        rotateYAxisTexts: 0,
        hideAxesAndRules: props.hideAxesAndRules,
        showXAxisIndices: showXAxisIndices,
        xAxisIndicesHeight: xAxisIndicesHeight,
        xAxisIndicesWidth: xAxisIndicesWidth,
        xAxisIndicesColor: xAxisIndicesColor,
        getPointerProps: getPointerProps,
        pointerIndex: pointerIndex,
        pointerX: pointerX,
        pointerY: pointerY,
        onEndReached: props.onEndReached,
        onStartReached: props.onStartReached,
        endReachedOffset: (_54 = props.endReachedOffset) !== null && _54 !== void 0 ? _54 : LineDefaults.endReachedOffset,
        onMomentumScrollEnd: props.onMomentumScrollEnd,
        extraWidthDueToDataPoint: extraWidthDueToBubble,
        customBackground: props.customBackground,
        onlyPositive: onlyPositive,
        highlightEnabled: LineDefaults.highlightEnabled,
        lowlightOpacity: LineDefaults.lowlightOpacity,
        xAxisLabelsAtBottom: xAxisLabelsAtBottom,
        onScrollEndDrag: props.onScrollEndDrag,
        allowFontScaling: allowFontScaling,
        showVerticalLines: props.showVerticalLines,
        xAxisLabelTexts: xAxisLabelTexts
    };
    return {
        totalWidth: totalWidth,
        animationDuration: animationDuration,
        containerHeightIncludingBelowXAxis: containerHeightIncludingBelowXAxis,
        getY: getY,
        barAndLineChartsWrapperProps: barAndLineChartsWrapperProps,
        getX: getX,
        maxValue: maxY,
        selectedIndex: selectedIndex,
        setSelectedIndex: setSelectedIndex,
        showTextOnFocus: showTextOnFocus,
        focusEnabled: focusEnabled,
        focusTogether: focusTogether,
        selectedLineNumber: selectedLineNumber,
        lastLineNumber: lastLineNumber,
        initialSpacing: initialSpacing,
        spacing: spacing,
        containerHeight: containerHeight,
        handleFocus: handleFocus,
        handleUnFocus: handleUnFocus,
        isAnimated: isAnimated,
        showBubbleOnFocus: showBubbleOnFocus,
        showBubbleLabelOnFocus: showBubbleLabelOnFocus,
        bubblesShape: bubblesShape,
        bubblesWidth: bubblesWidth,
        bubblesHeight: bubblesHeight,
        bubblesColor: bubblesColor,
        bubblesRadius: bubblesRadius,
        labelFontSize: labelFontSize,
        labelTextStyle: props.labelTextStyle,
        startIndex: startIndex,
        endIndex: endIndex,
        showValuesAsBubbleLabels: showValuesAsBubbleLabels,
        hideBubbles: hideBubbles,
        xAxisLabelsVerticalShift: xAxisLabelsVerticalShift,
        labelsExtraHeight: labelsExtraHeight,
        xAxisThickness: xAxisThickness,
        xAxisTextNumberOfLines: xAxisTextNumberOfLines,
        rotateLabel: rotateLabel,
        allowFontScaling: allowFontScaling,
        borderWidth: borderWidth,
        borderColor: borderColor,
        opacity: opacity,
        xAxisLabelTexts: xAxisLabelTexts,
        showRegressionLine: showRegressionLine,
        regressionLineConfig: regressionLineConfig,
        regressionLineX1: regressionLineX1,
        regressionLineY1: regressionLineY1,
        regressionLineX2: regressionLineX2,
        regressionLineY2: regressionLineY2,
        scatterChart: scatterChart
    };
};
