import React, { createContext, useContext, useState, useEffect, useCallback } from 'react';
import { Alert } from 'react-native';
import { useRouter } from 'expo-router';
import { usePro } from '../auth/ProContext';
import { Note } from '../../domain/entities/Note';
import { LocalNoteRepository } from '../../data/local/LocalNoteRepository';
import {
    SaveNoteUseCase,
    GetNoteUseCase,
    GetAllNotesUseCase,
    DeleteNoteUseCase,
    GetNoteByIdUseCase,
} from '../../domain/usecases/notes/NoteUseCases';
import { useStreaks } from '../auth/StreakContext';

interface NoteContextType {
    notes: Note[];
    loading: boolean;
    saveNote: (note: Note) => Promise<void>;
    deleteNote: (id: string) => Promise<void>;
    getNoteForVerse: (surah: number, verse: number) => Promise<Note | null>;
    getNoteById: (id: string) => Promise<Note | null>;
    refreshNotes: () => Promise<void>;
}

const NoteContext = createContext<NoteContextType | undefined>(undefined);

export const useNoteContext = () => {
    const context = useContext(NoteContext);
    if (!context) throw new Error('useNoteContext must be used within a NoteProvider');
    return context;
};

const repo = new LocalNoteRepository();
const saveUseCase = new SaveNoteUseCase(repo);
const getUseCase = new GetNoteUseCase(repo);
const getAllUseCase = new GetAllNotesUseCase(repo);
const deleteUseCase = new DeleteNoteUseCase(repo);
const getByIdUseCase = new GetNoteByIdUseCase(repo);

export function NoteProvider({ children }: { children: React.ReactNode }) {
    const [notes, setNotes] = useState<Note[]>([]);
    const [loading, setLoading] = useState(true);
    const { recordActivity } = useStreaks();
    const { isPro } = usePro();
    const router = useRouter();

    const refreshNotes = useCallback(async () => {
        setLoading(true);
        const data = await getAllUseCase.execute();
        setNotes(data);
        setLoading(false);
    }, []);

    useEffect(() => {
        refreshNotes();
    }, [refreshNotes]);

    const saveNote = async (note: Note) => {
        // GATING LOGIC: Limit Free users to 10 notes
        // Check if it's a NEW note (id might be generated by caller, but we can check if it already exists in state)
        // If note.id is already in notes, it's an update, which is allowed.
        // If it's new, we check limit.
        const isUpdate = notes.some(n => n.id === note.id);

        if (!isPro && !isUpdate && notes.length >= 7) {
            Alert.alert(
                'Note Limit Reached',
                'Free users can create up to 7 notes. Upgrade to Pro for unlimited notes.',
                [
                    { text: 'Cancel', style: 'cancel' },
                    { text: 'Upgrade to Pro', onPress: () => router.push('/paywall?reason=notes') }
                ]
            );
            return;
        }

        await saveUseCase.execute(note);
        await recordActivity(); // Update streak
        await refreshNotes();
    };

    const deleteNote = async (id: string) => {
        await deleteUseCase.execute(id);
        await refreshNotes();
    };

    const getNoteForVerse = async (surah: number, verse: number) => {
        return await getUseCase.execute(surah, verse);
    };

    const getNoteById = async (id: string) => {
        return await getByIdUseCase.execute(id);
    };

    return (
        <NoteContext.Provider
            value={{
                notes,
                loading,
                saveNote,
                deleteNote,
                getNoteForVerse,
                getNoteById,
                refreshNotes,
            }}>
            {children}
        </NoteContext.Provider>
    );
}
